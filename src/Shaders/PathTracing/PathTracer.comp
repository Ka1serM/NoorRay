#version 460
#pragma shader_stage(compute)

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#extension GL_EXT_ray_tracing: enable
#extension GL_GOOGLE_include_directive: enable
#extension GL_EXT_nonuniform_qualifier: enable
#extension GL_EXT_buffer_reference: require
#extension GL_EXT_scalar_block_layout: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require

// --- Include All Modules ---
#include "SharedStructs.h"
#include "Bindings.glsl"       
#include "Common.glsl"
#include "PrimaryRayGen.glsl"
#include "ShadeClosestHit.glsl"
#include "ShadeMiss.glsl"

// --- Stage-Specific Bindings ---
layout (set = 0, binding = 1, rgba32f) uniform image2D outputImage;

// --- Push Constants ---
layout (push_constant) uniform PushConstants {
    PushData pushData;
    CameraData camera;
} pushConstants;

// --- Software Intersection Logic ---
#include "Intersection.glsl"

void main() {
    const ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 screenSize = imageSize(outputImage);
    if (pixelCoord.x >= screenSize.x || pixelCoord.y >= screenSize.y) return;

    const int SAMPLES_PER_PIXEL = 1;

    uvec2 seed = pcg2d(uvec2(pixelCoord) ^ uvec2(pushConstants.pushData.frame * 16777619));
    uint rngStateX = seed.x, rngStateY = seed.y;

    vec3 accumulatedColor = vec3(0.0);

    for (int i = 0; i < SAMPLES_PER_PIXEL; ++i) {
        vec3 rayOrigin, rayDirection;
        generatePrimaryRay(pixelCoord, screenSize, pushConstants.camera, rngStateX, rngStateY, rayOrigin, rayDirection);

        Payload payload;
        payload.throughput = vec3(1.0);
        payload.done = false;
        payload.rngState = rngStateX;
        rand(payload.rngState);

        vec3 pathContribution = vec3(0.0);

        int diffuseBounces = 0, specularBounces = 0, transmissionBounces = 0;
        const int maxDiffuseBounces = 4, maxSpecularBounces = 6, maxTransmissionBounces = 12;

        for (int totalDepth = 0; totalDepth < 24; ++totalDepth) {
            // Software ray trace. It now uses the globally declared buffers via Bindings.glsl.
            HitInfo hit = traceScene(rayOrigin, rayDirection);

            if (hit.instanceIndex == -1) {
                shadeMiss(rayDirection, pushConstants.pushData, payload);
            }
            else {
                const ComputeInstance inst = sceneInstances[hit.instanceIndex];
                const MeshAddresses mesh = instances[inst.meshId];
                const Face face = FaceBuffer(mesh.faceAddress).data[hit.primitiveIndex];
                const Material material = MaterialBuffer(mesh.materialAddress).data[face.materialIndex];

                const Vertex v0 = VertexBuffer(mesh.vertexAddress).data[IndexBuffer(mesh.indexAddress).data[3 * hit.primitiveIndex + 0]];
                const Vertex v1 = VertexBuffer(mesh.vertexAddress).data[IndexBuffer(mesh.indexAddress).data[3 * hit.primitiveIndex + 1]];
                const Vertex v2 = VertexBuffer(mesh.vertexAddress).data[IndexBuffer(mesh.indexAddress).data[3 * hit.primitiveIndex + 2]];
                vec3 localPos = interpolateBarycentric(hit.barycentrics, v0.position, v1.position, v2.position);
                vec3 localNrm = normalize(interpolateBarycentric(hit.barycentrics, v0.normal, v1.normal, v2.normal));
                vec2 uv = interpolateBarycentric(hit.barycentrics, v0.uv, v1.uv, v2.uv);

                vec3 worldPos = (inst.transform * vec4(localPos, 1.0)).xyz;
                vec3 worldNrm = normalize(transpose(inverse(mat3(inst.transform))) * localNrm);

                // Call shared hit logic.
                shadeClosestHit(worldPos, worldNrm, uv, rayDirection, material, payload);
            }

            pathContribution += payload.throughput * payload.color;
            if (payload.done) break;

            switch (payload.bounceType) {
                case BOUNCE_TYPE_DIFFUSE: if (++diffuseBounces > maxDiffuseBounces) payload.done = true; break;
                case BOUNCE_TYPE_SPECULAR: if (++specularBounces > maxSpecularBounces) payload.done = true; break;
                case BOUNCE_TYPE_TRANSMISSION: if (++transmissionBounces > maxTransmissionBounces) payload.done = true; break;
            }
            if (payload.done) break;

            rayOrigin = payload.position;
            rayDirection = payload.nextDirection;
        }

        rngStateX = payload.rngState;
        rand(rngStateX);
        accumulatedColor += pathContribution;
    }

    vec3 finalColor = accumulatedColor / float(SAMPLES_PER_PIXEL);
    vec3 previousColor = imageLoad(outputImage, pixelCoord).rgb;
    finalColor = (finalColor + previousColor * float(pushConstants.pushData.frame)) / float(pushConstants.pushData.frame + 1);
    imageStore(outputImage, pixelCoord, vec4(finalColor, 1.0));
}
